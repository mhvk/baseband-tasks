# Licensed under the GPLv3 - see LICENSE

import numpy as np
from astropy.utils import lazyproperty


__all__ = ['FFTMakerBase', 'FFTBase', 'get_fft_maker']


FFT_MAKER_CLASSES = {}
"""Dict for storing FFT maker classes, indexed by their name or prefix."""


class FFTMakerMeta(type):
    """Registry of FFT maker classes.

    Registers classes using the `FFT_MAKER_CLASSES` dict, using a key
    generated by lowercasing the class's name and removing any trailing
    'fftmaker' (eg. the key for 'NumpyFFTMaker' is 'numpy').  The class
    automatically registers any subclass of `FFTMakerBase`, checking for key
    conflicts before registering.  Used by `get_fft_maker` to select classes.

    Users that wish to register their own FFT maker class should either
    subclass `FFTMakerBase` or use `FFTMakerMeta` as the metaclass.
    """
    _registry = FFT_MAKER_CLASSES

    def __init__(cls, name, bases, dct):

        # Ignore FFTMakerBase.
        if name != 'FFTMakerBase':

            # Extract name from class.
            key = name.lower()

            if key.endswith('fftmaker') and len(key) > 8:
                key = key[:-8]

            # Check if class is already registered.
            if key in FFTMakerMeta._registry:
                raise ValueError("key {0} already registered in "
                                 "FFT_MAKER_CLASSES.".format(key))

            FFTMakerMeta._registry[key] = cls

        super().__init__(name, bases, dct)


class FFTMakerBase(metaclass=FFTMakerMeta):
    """Base class for all FFT factories."""

    def __call__(self, shape, dtype, direction='forward', axis=0, ortho=False,
                 sample_rate=None):
        """Placeholder for FFT setup."""
        raise NotImplementedError()

    def get_freq_data_info(self, shape, dtype, axis=0):
        """Determine frequency-domain array shape and dtype.

        Parameters
        ----------
        shape : tuple
            Shape of the time-domain data array, i.e. the input to the forward
            transform and the output of the inverse.
        dtype : str or `~numpy.dtype`
            Data type of the time-domain data array.  May pass either the
            name of the dtype or the `~numpy.dtype` object.
        axis : int, optional
            Axis of transform.  Default: 0.

        Returns
        -------
        freq_shape : tuple
            Shape of the frequency-domain data array.
        freq_dtype : `~numpy.dtype`
            Data type of the frequency-domain data array.
        """
        if dtype.kind == 'f':
            freq_shape = list(shape)
            freq_shape[axis] = shape[axis] // 2 + 1
            freq_dtype = np.dtype('c{0:d}'.format(2 * dtype.itemsize))
            return tuple(freq_shape), freq_dtype
        # No need to make a copy, since we're not altering shape.
        return shape, dtype


class FFTBase(object):
    """Framework for single pre-defined FFT and its associated metadata."""

    def __init__(self, direction):
        self._direction = direction if direction == 'inverse' else 'forward'

    @property
    def direction(self):
        """Direction of the FFT ('forward' or 'inverse')."""
        return self._direction

    @property
    def time_shape(self):
        """Shape of the time-domain data."""
        return self._time_shape

    @property
    def time_dtype(self):
        """Data type of the time-domain data."""
        return self._time_dtype

    @property
    def freq_shape(self):
        """Shape of the frequency-domain data."""
        return self._freq_shape

    @property
    def freq_dtype(self):
        """Data type of the frequency-domain data."""
        return self._freq_dtype

    @property
    def axis(self):
        """Axis over which to perform the FFT."""
        return self._axis

    @property
    def ortho(self):
        """Use orthogonal normalization.

        If `True`, both forward and backward transforms are scaled by
        1 / sqrt(n), where n is the size of time-domain array's transform
        axis.  If `False`, forward transforms are unscaled and inverse ones
        scaled by 1 / n.
        """
        return self._ortho

    @property
    def sample_rate(self):
        """Rate of samples in the time domain."""
        return self._sample_rate

    @lazyproperty
    def freq(self):
        """FFT sample frequencies.

        Uses `numpy.fft.fftfreq` for complex time-domain data, which returns,
        for an array of length n and a time-domain ``sample_rate``,

            f = [0, 1, ...,   n/2-1,     -n/2, ..., -1] * sample_rate / n

        if n is even, and

            f = [0, 1, ..., (n-1)/2, -(n-1)/2, ..., -1] * sample_rate / n

        if n is odd.

        For real time-domain data, `numpy.fft.rfftfreq` is used, which returns

            f = [0, 1, ...,     n/2-1,     n/2] * sample_rate / n

        if n is even, and

            f = [0, 1, ..., (n-1)/2-1, (n-1)/2] * sample_rate / n

        if n is odd.

        If ``sample_rate`` is `None`, a unitless rate of 1 is used.

        Returns
        -------
        freqs : `~numpy.ndarray` or array of `~astropy.units.Quantity`
            Sample frequencies, with shape (len(f), 1, ..., 1).  The trailing
            dimensions of length unity are to facilitate broadcasting when
            operating on ``freqs``.
        """
        sample_rate = 1. if self.sample_rate is None else self.sample_rate
        a_length = self._time_shape[self.axis]
        if self._time_dtype.kind == 'f':
            freqs = np.fft.rfftfreq(a_length, d=(1. / sample_rate))
        else:
            freqs = np.fft.fftfreq(a_length, d=(1. / sample_rate))
        # Reshape freqs to add trailing dimensions.
        freqs.shape = (freqs.shape +
                       (len(self._time_shape) - self.axis - 1) * (1,))
        return freqs

    def __call__(self, a):
        """Perform FFT.

        To display the direction of the transform and shapes and dtypes of the
        arrays, use `print` or `repr`.

        Parameters
        ----------
        a : array_like
            Input data.

        Returns
        -------
        out : `~numpy.ndarray`
            Transformed data.
        """
        return self._fft(a)

    def inverse(self):
        """Return inverse transform.

        Returns
        -------
        inverse_transform : `~scintillometry.fourier.base.FFTBase` subclass
            Returns a new instance of the calling class with reversed transform
            direction.
        """
        return self.__class__(
            direction=('forward' if self.direction == 'inverse'
                       else 'inverse'))

    def copy(self):
        return self.__class__(direction=self.direction)

    def __copy__(self):
        return self.copy()

    def __eq__(self, other):
        return (self.direction == other.direction and
                self.time_shape == other.time_shape and
                self.time_dtype == other.time_dtype and
                self.freq_shape == other.freq_shape and
                self.freq_dtype == other.freq_dtype and
                self.axis == other.axis and
                self.ortho == other.ortho and
                self.sample_rate == other.sample_rate)

    def __repr__(self):
        return ("<{s.__class__.__name__}"
                " direction={s.direction},\n"
                "    axis={s.axis}, ortho={s.ortho},"
                " sample_rate={s.sample_rate}\n"
                "    Time domain: shape={s.time_shape},"
                " dtype={s.time_dtype}\n"
                "    Frequency domain: shape={s.freq_shape},"
                " dtype={s.freq_dtype}>".format(s=self))


def get_fft_maker(fft_engine, **kwargs):
    """FFT factory selector.

    Parameters
    ----------
    fft_engine : {'numpy', 'pyfftw'}
        Keyword for the FFT maker class.
    **kwargs
        Additional keyword arguments for initializing the maker class
        (eg. ``n_simd`` for 'pyfftw').
    """
    return FFT_MAKER_CLASSES[fft_engine](**kwargs)
